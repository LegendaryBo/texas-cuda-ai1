package pl.wroc.uni.ii.evolution.engine.operators.spacespecific.realvector;

import pl.wroc.uni.ii.evolution.utils.EvShrinkageCovarianceEstimator;
import pl.wroc.uni.ii.evolution.engine.prototype.operators.EvSelection;
import pl.wroc.uni.ii.evolution.engine.EvPopulation;
import pl.wroc.uni.ii.evolution.engine.individuals.EvRealVectorIndividual;
import pl.wroc.uni.ii.evolution.utils.EvRandomizer;
import pl.wroc.uni.ii.evolution.engine.prototype.EvOperator;
import pl.wroc.uni.ii.evolution.engine.prototype.EvObjectiveFunction;
import pl.wroc.uni.ii.evolution.engine.operators.general.selections.EvKBestSelection;
import java.util.ArrayList;
import java.math.BigDecimal;
import Jama.Matrix;
import Jama.CholeskyDecomposition;


/**
 * Class representing covariance operator.
 * 
 * It selects sample population from given population.
 * Then it estimates covariance matrix using schrinkage estimator.
 * Finaly it generates individuals using covariance matrix as a model.
 * 
 * @author Szymon Fogiel (szymek.fogiel@gmail.com)
 */
public class EvRealVectorCovarianceOperator implements
    EvOperator<EvRealVectorIndividual> {  
  
  /** Auxilary value for rounding individuals values. */
  private final double rounder = Math.pow(10, 100);  
  
  /** Covariance matrix used by the algorithm. */
  private Matrix covariance_matrix;
  
  /** Mean vector. */
  private Matrix mean_vector;
  
  /** Random vector used for generating individuals. */
  private Matrix random_vector;
  
  /** Shrinkage estimator. */
  private EvShrinkageCovarianceEstimator covariance_estimator;
    
  /** Selection operator used for selecting group of individuals from
   * the population. */   
  private EvSelection<EvRealVectorIndividual> selection_operator;
    
  
  /**
   * Constructor.
   * 
   * @param select_operator an operator used to select group of individuals
   * from population
   */
  public EvRealVectorCovarianceOperator(
      final EvSelection<EvRealVectorIndividual> select_operator) {
    
    this.selection_operator = select_operator;
    this.covariance_estimator = new EvShrinkageCovarianceEstimator();
  }
  
  
  /**
   * Constructor.
   * As a selection operator it selects best individuals in number
   * defined by size_of_selection.
   * 
   * @param size_of_selection size of selection used by selection
   * operator
   */
  public EvRealVectorCovarianceOperator(final int size_of_selection) {
    this(new EvKBestSelection<EvRealVectorIndividual>(size_of_selection));
  }  
  
  
  /**
   * Applies operator to population.
   * 
   * @param population population to apply operator to
   * @return population generated by the operator
   */
  public EvPopulation<EvRealVectorIndividual> apply(
      final EvPopulation<EvRealVectorIndividual> population) {
    
    /* Length of population's individuals' chromosomes */
    int chromosome_length = population.get(0).getDimension();
    
    /* Used for decomposing covariance matrix */
    CholeskyDecomposition decomposition;
    
    EvRealVectorIndividual individual;
    
    /* population to return */
    EvPopulation<EvRealVectorIndividual> return_population =
        new EvPopulation<EvRealVectorIndividual>();
    
    /* sample population selected by selection operator */
    EvPopulation<EvRealVectorIndividual> selected_population;
    
    /* objective function */
    EvObjectiveFunction< ? > objective_function =
        population.get(0).getObjectiveFunction(0);
    
    /* list holding positions at which values are equal in all individuals */
    ArrayList<Integer> positions = new ArrayList<Integer>();       
    
    /* list holding these values */
    ArrayList<Double> values = new ArrayList<Double>();    

    double[] means; // array holding means
        
    /* result of covaraince matrix decomposition */
    Matrix decomposed_matrix;            
    
    /* select sample population */
    selected_population = selection_operator.apply(population);

    /* fills lists positions and values */
    getEqualValues(positions, values, selected_population);
    
    /* if all individuals are equal return population of equal
     * individuals */
    if (chromosome_length == positions.size()) {
      return generateEqualPopulation(population.size(),
          selected_population.get(0));
    }
    
    /* generate population without equal values */      
    selected_population = generetePopulation(positions,
        selected_population);
    
        
    /* calculate covariance matrix and mean vector */
    covariance_estimator.calculateCovarianceMatrix(selected_population);
    mean_vector = new Matrix(chromosome_length - positions.size(), 1);
    means = covariance_estimator.getMeanVector();
        
    for (int i = 0; i < chromosome_length - positions.size(); i++) {
      mean_vector.set(i, 0, means[i]);
    }
    
    covariance_matrix =
      new Matrix(covariance_estimator.getEstimatedCovarianceMatrix());

    decomposition = new CholeskyDecomposition(covariance_matrix);    
    
    /* decomposed covariance matrix */
    decomposed_matrix = decomposition.getL();
    
    random_vector = new Matrix(chromosome_length - positions.size(), 1);
    
    for (int i = 0; i < population.size(); i++) {
      individual = generateIndividual(chromosome_length, positions, values,
          decomposed_matrix);
      
      individual.addObjectiveFunction(objective_function);
      return_population.add(individual);
    }   
    
    return return_population;
  }   
    
  
  /**
   * Finds positions and values which are equal in all individuals
   * in selected population.
   * 
   * @param positions positions on which values are equal will be added here
   * @param values values at specified positions
   * @param population sample population
   */
  private void getEqualValues(final ArrayList<Integer> positions,
      final ArrayList<Double> values,
      final EvPopulation<EvRealVectorIndividual> population) {
    
    int chromosome_length = population.get(0).getDimension();
    
    int number_in_population;
    
    double value;
    
    for (int i = 0; i < chromosome_length; i++) {
      number_in_population = 0;
      value = population.get(0).getValue(i);
      while (number_in_population < population.size()
          && population.get(number_in_population).getValue(i)
          == value) {
        value = population.get(number_in_population).getValue(i);
        number_in_population++;
      }
      
      /* if all individuals on position i have the same value */
      if (number_in_population == population.size()) { 
        positions.add(i);
        values.add(value);
      }
    }
  }
  
  
  /**
   * Generates a population with individuals without genes
   * which are equal in all individuals in given population.
   * 
   * @param positions list of positions at which values are equal
   * @param population sample population
   * @return generated population
   */
  private EvPopulation<EvRealVectorIndividual> generetePopulation(
      final ArrayList<Integer> positions,      
      final EvPopulation<EvRealVectorIndividual> population) {
    
    /* generated population */
    EvPopulation<EvRealVectorIndividual> selected;
    
    EvRealVectorIndividual individual;
       
    int new_dim; // dimension of individuals without equal values
    
    int chromosome_length = population.get(0).getDimension();
    
    /* if there are positions at which all individuals have equal values */   
    if (positions.size() > 0) {
      selected = new EvPopulation<EvRealVectorIndividual>();
      
      new_dim = chromosome_length - positions.size();
            
      for (int i = 0; i < population.size(); i++) {        
        individual = new EvRealVectorIndividual(new_dim);
        for (int j = 0, k = 0, n = 0; j < chromosome_length; j++) {
          if (n >= positions.size() || j != positions.get(n)) {
            individual.setValue(k, population.get(i).getValue(j));
            k++;
          } else {
            n++;
          }
        }
        selected.add(individual);
      }
      
      return selected;
    } else {
      return population;
    }
  }
  
  
  /**
   * Generates a population of equal individuals.
   * 
   * @param size size of a population
   * @param individual an individual which copies are in a population
   * @return generated population
   */
  private EvPopulation<EvRealVectorIndividual> generateEqualPopulation(
      final int size, final EvRealVectorIndividual individual) {
    
    EvPopulation<EvRealVectorIndividual> population =
      new EvPopulation<EvRealVectorIndividual>();
    
    for (int i = 0; i < size; i++) {
      population.add(individual.clone());
    }
    
    return population;
  }
  
  
  /**
   * Generates random individual.
   * 
   * @param chromosome_length length of individual's chromosome
   * @param positions list of positions of genes with equal values
   * @param values list of values
   * @param decomposed_matrix result of covariance matrix decomposition
   * @return generated individual
   */
  private EvRealVectorIndividual generateIndividual(
      final int chromosome_length,
      final ArrayList<Integer> positions, final ArrayList<Double> values,
      final Matrix decomposed_matrix) {
        
    Matrix individual_vector; // vector holding individual's genes
    
    EvRealVectorIndividual individual; // individual to generate
    
    BigDecimal rounded; // used for rounding values
    
    for (int j = 0; j < chromosome_length - positions.size(); j++) {
      random_vector.set(j, 0, EvRandomizer.INSTANCE.nextGaussian(0, 1));     
    }
    
    individual_vector =
      mean_vector.plus(decomposed_matrix.times(random_vector));
    individual = new EvRealVectorIndividual(chromosome_length);    
    
    for (int j = 0, k = 0, n = 0; j < chromosome_length; j++) {
      if (n >= positions.size() || j != positions.get(n)) {        
        rounded = new BigDecimal(rounder * individual_vector.get(k, 0));
        individual.setValue(j, rounded.doubleValue() / rounder);
        k++;
      } else {
        individual.setValue(j, values.get(n));
        n++;
      }
    } 
    
    return individual;
  }
}



